package main
// The built-in package `strconv` provides the number parsing.

import "strconv"
import "fmt"

func main() {
	
	s := strconv.FormatBool(true)
	fmt.Printf("%T, %v\n", s, s)
	
	// FormatFloat converts the floating-point number f to a string
	s64 := strconv.FormatFloat(3.1415926535, 'E', -1, 64)
	fmt.Printf("%T, %v\n", s64, s64)
	
	// FormatInt returns the string representation of i in the given base, for 2 <= base <= 36
	s16 := strconv.FormatInt(-42, 16)
	fmt.Printf("%T, %v\n", s16, s16)

	s32 := strconv.FormatUint(42, 32)
	fmt.Printf("%T, %v\n", s32, s32)

    // With `ParseFloat`, this `64` tells how many bits of precision to parse.
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Printf("%T, %v\n", f, f)

    // For `ParseInt`, the `0` means infer the base from
    // the string. `64` requires that the result fit in 64 bits.
    i, _ := strconv.ParseInt("123", 0, 64)
    fmt.Printf("%T, %v\n", i, i)

    // `ParseInt` will recognize hex-formatted numbers.
    d, _ := strconv.ParseInt("0x1c8", 0, 64)
    fmt.Printf("%T, %v\n", d, d)

    // A `ParseUint` is also available.
    u, _ := strconv.ParseUint("789", 0, 64)
    fmt.Printf("%T, %v\n", u, u)
	
	// ParseBool returns the boolean value represented by the string
	v := "true"
	if a, err := strconv.ParseBool(v); err == nil {
		fmt.Printf("%T, %v\n", a, a)
	}

    // `Atoi` is a convenience function for basic base-10 `int` parsing.
    k, _ := strconv.Atoi("135")
    fmt.Printf("%T, %v\n",k, k)

	// Itoa (int to string)
	m := strconv.Itoa(10)
	fmt.Printf("%T, %v\n", m, m)

    // Parse functions return an error on bad input.
    // _, e := strconv.Atoi("wat")
    //fmt.Println(e)

	// Quote returns a double-quoted Go string literal representing s. 
	// The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) 
	// for control characters and non-printable characters as defined by IsPrint.
    q := strconv.Quote("Hello, 世界")
    fmt.Println(q)

    r := strconv.QuoteToASCII("Hello, 世界")
    fmt.Println(r)
	
	// Unquote interprets p as a single-quoted, double-quoted, 
	// or backquoted Go string literal, returning the string value that p quotes.
	p, err := strconv.Unquote("'\u2639\u2639'")
	fmt.Printf("%q, %v\n", p, err)
	
	// AppendQuote appends a double-quoted Go string literal representing s, 
	// as generated by Quote, to dst and returns the extended buffer.
	b := []byte("quote:")
	b = strconv.AppendQuote(b, `"Fran & Freddie's Diner"`)
	fmt.Println(string(b))

	// AppendInt appends the string form of the integer i, 
	// as generated by FormatInt, to dst and returns the extended buffer.
	b16 := []byte("int (base 16):")
	b16 = strconv.AppendInt(b16, -42, 16)
	fmt.Println(string(b16))
	
	// AppendUint appends the string form of the unsigned integer i, 
	// as generated by FormatUint, to dst and returns the extended buffer.
	b32 := []byte("uint (base 32):")
	b32 = strconv.AppendUint(b32, 42, 32)
	fmt.Println(string(b32))
	
	// AppendFloat appends the string form of the floating-point number f, 
	// as generated by FormatFloat, to dst and returns the extended buffer.
	b64 := []byte("float64:")
	b64 = strconv.AppendFloat(b64, 3.1415926535, 'E', -1, 64)
	fmt.Println(string(b64))
	
	// AppendBool appends "true" or "false", according to the value of b,
	// to dst and returns the extended buffer.
	bo := []byte("bool:")
	bo = strconv.AppendBool(bo, true)
	fmt.Println(string(bo))

}